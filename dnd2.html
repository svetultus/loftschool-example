<!DOCTYPE html>
<html lang="en">
    <head>
        <meta charset="UTF-8">
        <title>Title</title>
        <link href="https://maxcdn.bootstrapcdn.com/bootstrap/3.3.6/css/bootstrap.min.css" rel="stylesheet">
        <style>
            .container {
                display: flex;
                padding: 30px;
                height: 500px;
            }

            .drop-zone {
                display: flex;
                flex-basis: 50%;
                flex-wrap: wrap;
                align-content: start;
                padding: 15px;
                border: 3px dashed #b3b3b3;
                border-radius: 10px;
            }

            .item, .new-item {
                margin: 0 10px 10px 0;
                display: flex;
                justify-content: center;
                align-items: center;
                color: hsla(0, 0%, 40%, 1);
            }

            .item, .new-item {
                border: 2px dashed #783db3;
                border-radius: 10px;
                width: 50px;
                height: 50px;
                cursor: move;
                user-select: none;
            }

            .new-item {
                cursor: pointer;
                border: 2px dashed #b3b3b3;
                font-size: 16px;
            }

        </style>
    </head>
    <body class="container text-center">
        <div class="container">
            <div class="drop-zone">
                <div class="new-item">+</div>
            </div>

            <div class="drop-zone">
                <div class="new-item">+</div>
            </div>

            <div class="drop-zone">
                <div class="new-item">+</div>
            </div>

            <div class="drop-zone">
                <div class="new-item">+</div>
            </div>
        </div>

        <script>
            let counter = 0;
            let currentDrag;

            document.addEventListener('click', e => {
                if (e.target.classList.contains('new-item')) {
                    const newItem = createItem();
                    const zone = getCurrentZone(e.target);

                    zone.insertBefore(newItem, zone.lastElementChild)
                }
            });

            document.addEventListener('dragstart', (e) => {
                const zone = getCurrentZone(e.target);

                if (zone) {
                    currentDrag = { startZone: zone, node: e.target };
                    e.dataTransfer.setData('text/html', 'dragstart');
                }

            });

            document.addEventListener('dragover', (e) => {
                const zone = getCurrentZone(e.target);
                if (zone) {
                    e.preventDefault();
                } else if (e.target.classList.contains('item')) {
                    e.preventDefault();
                }
                if (e.target === document.body || e.target === document.querySelector('html') || e.target === document.querySelector('.container')) {
                    e.preventDefault();
                }
            });

            document.addEventListener('drop', (e) => {
                if (currentDrag) {
                    const zone = getCurrentZone(e.target);
                    let x, y, targetX;
                    let halfWidth = Math.round(e.target.clientWidth/2);
                    let deltaY = 12;

                    e.preventDefault();
                    if (zone) {
                        if (e.target.classList.contains('item')) {
                            x = e.pageX;
                            targetX = e.target.offsetLeft;

                            // если мышь отпустили левее середины целевого элемента, но попали на элемент
                            if (targetX + halfWidth > x) {
                                zone.insertBefore(currentDrag.node, e.target);
                            }
                            else {
                                zone.insertBefore(currentDrag.node, e.target.nextElementSibling);
                            }
                        } 
                        // если отпустили мышь рядом с элементом, но на него не попали
                        else if (zone === e.target) { 
                            // ищем ближайшего соседа
                            let prev = getPrevElem(e, zone, 20);

                            if (prev) {
                                if (prev.nextElementSibling.classList.contains('new-item')) {
                                    zone.insertBefore(currentDrag.node, zone.lastElementChild);
                                } else {
                                    zone.insertBefore(currentDrag.node, prev);
                                }
                            } else {
                                zone.insertBefore(currentDrag.node, zone.lastElementChild);
                            }
                        }
                    } else {
                        currentDrag.node.parentElement.removeChild(currentDrag.node);
                    }

                    currentDrag = null;
                }
            });

            function createItem() {
                const newDiv = document.createElement('div');

                newDiv.textContent = counter++;
                newDiv.classList.add('item');
                newDiv.draggable = true;

                return newDiv;
            }

            function getCurrentZone(from) {
                // return from.parentNode;
                // return from.closest('.drop-zone');

                do {
                    if (from.classList.contains('drop-zone')) {
                        return from;
                    }
                } while (from = from.parentElement);

                return null;
            }

            function getPrevElem (e, zone, delta) {
                x = e.pageX;
                y = e.pageY;
                let result;
                let items = zone.querySelectorAll('.item');

                //выбираем ряд элементов, ближайших по Y
                let itemsRow = Array.prototype.filter.call(items, (element) => {
                    return ( y >= (element.offsetTop - delta) 
                        && y <= (element.offsetTop + element.clientHeight + delta) );
                    });
                // из них выбираем элементы, ближайшие по X
                items = itemsRow.filter((element) => {
                    return (x >= (element.offsetLeft - delta) 
                        && x <= (element.offsetLeft + element.clientWidth + delta))
                });

                switch (items.length) {
                    case 0:
                        result = false;
                        break;
                    case 1:
                        if (items[0] === itemsRow[0]) {
                            //был выбран самый левый элемент в ряду
                            result = items[0];
                        } else if (items[0] === itemsRow[itemsRow.length-1]) {
                            //был выбран самый правый элемент в ряду
                            result = (items[0].nextElementSibling.classList.contains('new-item')) ? items[0] : items[0].nextElementSibling;
                        }
                        break;
                    case 2:
                        result = items[1];
                        break;
                    default:
                        result = false;
                        break;
                }

                return result;
            }
        </script>
    </body>
</html>
